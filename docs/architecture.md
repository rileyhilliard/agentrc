# Architecture

agentrc is a compiler. It reads a universal source format (`.agentrc/`), builds an intermediate representation, and emits platform-specific output. If you've worked with Babel, PostCSS, or any source-to-source transpiler, the mental model is the same.

## The pipeline

```
.agentrc/          Loader         IR Builder        Adapters         Writer
────────── ──────► ──────── ──►  ────────── ──►   ────────── ──►  ──────────
config.yaml     Parse YAML     Normalize to       Per-platform    Write files
rules/*.md      Parse MD +     platform-agnostic  output           + headers
commands/*.md   frontmatter    types                               + manifest
skills/*/                                                          + .gitignore
agents/*.md
```

Each stage has a single responsibility. Data flows in one direction.

### Loader

**File:** `src/core/loader.ts`

Reads the `.agentrc/` directory and parses everything into raw data structures. Handles:

- `config.yaml` parsing and validation via `src/core/config.ts`
- `rules/*.md` and `commands/*.md` via frontmatter parsing
- `skills/*/SKILL.md` with supporting file discovery
- `agents/*.md` with model and tools frontmatter

The loader validates that `.agentrc/` exists and that `config.yaml` is present. It does not validate the relationships between files.

**Key type:** `LoadedSource` contains the raw parsed data for all sources.

### Config parser

**File:** `src/core/config.ts`

Parses `config.yaml` using the `yaml` package and validates it against a JSON schema using `ajv`. The schema is inlined in the source (not loaded from disk at runtime) so the compiled CLI works without needing to resolve schema files.

**Key type:** `AgentrcConfig` with `version`, `targets`, and `hooks`.

### Frontmatter parser

**File:** `src/core/frontmatter.ts`

Wraps the `gray-matter` library with normalization:

- `globs` accepts either a string or an array (normalizes to array)
- `priority` validates against the allowed values and defaults to `"normal"`
- `aliases` normalizes to array
- Boolean fields use `Boolean()` coercion

**Key type:** `ParsedFrontmatter` with optional `globs`, `alwaysApply`, `description`, `priority`, `aliases`, `model`, and `tools`.

### IR builder

**File:** `src/core/ir.ts`

Converts `LoadedSource` into the intermediate representation. This is the normalization step where raw parsed data becomes a clean, typed model that adapters can consume without worrying about parsing details.

The IR builder also handles:
- **Scope determination:** Based on frontmatter fields, each rule gets a scope: `always`, `glob`, `description`, or `manual`. The precedence is: `alwaysApply` > `globs` > `description` > none.
- **Priority sorting:** Rules are sorted by priority (`critical` > `high` > `normal` > `low`) so adapters don't need to re-sort.

**Key types:**
- `IR` - The complete intermediate representation
- `Rule` - Normalized rule with `scope`, `priority`, `content`, optional `globs` and `description`
- `Hook` - Event, match pattern, command, description
- `AgentCommand` - Name, description, content, optional aliases
- `Skill` - Name, description, content, supporting files map
- `Agent` - Name, description, content, optional model and tools

### Adapters

**Directory:** `src/adapters/`

Each adapter implements the `Adapter` interface:

```typescript
interface Adapter {
  name: string;
  generate(ir: IR): AdapterResult;
}
```

`AdapterResult` contains the output files, warnings, and lists of native vs. degraded features. Adapters are pure functions of the IR. They don't read the filesystem or have side effects.

For platforms that only need a single markdown file, `createGenericAdapter(name, outputPath)` in `src/adapters/generic-markdown.ts` is a factory that handles the common case. Aider, Junie, Amazon Q, Amp, and Roo all use this.

The adapter registry (`src/adapters/registry.ts`) maps platform names to adapter instances and provides `getAdapter()` for lookup.

### Writer

**File:** `src/output/writer.ts`

Handles all file I/O for generated output. Responsibilities:

- **Generated-file headers:** Adds a comment header to every output file (`<!-- Generated by agentrc -->` for markdown, `__generated_by` key for JSON, `#` comment for YAML). This lets agentrc identify its own files on subsequent runs.
- **JSON deep merge:** For JSON files like `.claude/settings.json`, if the file already exists and wasn't generated by agentrc, the writer deep-merges its keys into the existing file instead of overwriting. Arrays are replaced, objects are recursively merged.
- **Backup:** Files that would be overwritten and don't have an agentrc header are backed up to `.agentrc/.backup/` before being replaced.
- **Manifest:** After writing, a manifest (`.agentrc/.manifest.json`) records every generated file with its SHA-256 hash. This enables `agentrc clean` and stale file detection.

### Gitignore manager

**File:** `src/output/gitignore.ts`

Manages a fenced block in `.gitignore`:

```
# >>> agentrc managed (do not edit) >>>
.claude/rules/typescript-strict.md
.cursor/rules/typescript-strict.mdc
# <<< agentrc managed <<<
```

Generated files are added to `.gitignore` so they aren't committed. The source of truth is `.agentrc/`, not the generated output.

## Key design decisions

**Why an IR?** Without it, each adapter would need to parse frontmatter, resolve scopes, and sort by priority independently. The IR normalizes all of this once, so adapters only deal with clean, typed data. It also makes testing simpler: you can test the IR builder and adapters independently.

**Why deep merge for JSON?** Users often have their own `.claude/settings.json` with custom configuration. Overwriting it would lose their settings. Deep merging adds agentrc's keys (like hooks) alongside existing config.

**Why headers on generated files?** agentrc needs to distinguish "this file was generated by us and is safe to overwrite" from "this file was created by the user and should be backed up first." The header is the marker.

**Why priority ordering?** Windsurf has hard character limits. Without priority ordering, there's no principled way to decide which rules get dropped when limits are hit. By sorting rules at the IR level, every adapter benefits from consistent ordering.

**Why `generic-markdown` as a factory?** Many platforms only support a single instructions file with no special features. The `createGenericAdapter()` factory avoids duplicating the same "fold everything into one markdown file" logic across five adapters.

## Source layout

```
src/
├── cli.ts                        # CLI entry point (Commander)
├── commands/                     # CLI command handlers
│   ├── init.ts                   # agentrc init
│   ├── build.ts                  # agentrc build
│   ├── validate.ts               # agentrc validate
│   ├── inspect.ts                # agentrc inspect <platform>
│   ├── clean.ts                  # agentrc clean
│   └── migrate.ts                # agentrc migrate
├── core/                         # Core transpiler pipeline
│   ├── config.ts                 # config.yaml parser + JSON schema validation
│   ├── frontmatter.ts            # Markdown frontmatter parser (gray-matter wrapper)
│   ├── ir.ts                     # IR types + builder
│   └── loader.ts                 # .agentrc/ directory reader
├── adapters/                     # Platform adapters
│   ├── adapter.ts                # Adapter interface + types
│   ├── registry.ts               # Adapter lookup registry
│   ├── claude.ts                 # Claude Code adapter
│   ├── cursor.ts                 # Cursor adapter
│   ├── copilot.ts                # GitHub Copilot adapter
│   ├── windsurf.ts               # Windsurf adapter (with char limits)
│   ├── cline.ts                  # Cline adapter
│   ├── gemini.ts                 # Gemini adapter
│   ├── codex.ts                  # Codex (OpenAI) adapter
│   └── generic-markdown.ts       # Factory for single-file adapters
└── output/                       # Output formatting
    ├── writer.ts                 # File writer + headers + manifest + merging
    └── gitignore.ts              # .gitignore managed block
```
