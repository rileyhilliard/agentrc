import { createHash } from 'node:crypto';
import { cp, mkdir, readFile, stat, writeFile } from 'node:fs/promises';
import { dirname, extname, join } from 'node:path';
import type { OutputFile } from '../adapters/adapter.ts';

const VERSION = '0.1.0';
const MANIFEST_PATH = '.agentrc/.manifest.json';
const BACKUP_DIR = '.agentrc/.backup';

const MD_HEADER = `<!-- Generated by agentrc v${VERSION} — edit .agentrc/ instead, changes here will be overwritten -->`;
const YAML_HEADER = `# Generated by agentrc v${VERSION} — edit .agentrc/ instead, changes here will be overwritten`;
const JSON_GENERATED_KEY = `agentrc@${VERSION}`;

export interface WriteOptions {
  rootDir: string;
  dryRun?: boolean;
}

export interface WriteResult {
  written: string[];
  backed_up: string[];
  warnings: string[];
}

export interface ManifestEntry {
  path: string;
  hash: string;
}

export interface Manifest {
  version: string;
  generatedAt: string;
  files: ManifestEntry[];
}

export function computeHash(content: string): string {
  return createHash('sha256').update(content).digest('hex');
}

// Check if a file's content contains an agentrc-generated header
export function hasGeneratedHeader(content: string): boolean {
  if (content.includes(MD_HEADER)) return true;
  if (content.includes(YAML_HEADER)) return true;
  // For JSON, check for the __generated_by key
  if (content.includes('"__generated_by"')) {
    try {
      const parsed = JSON.parse(content) as Record<string, unknown>;
      return (
        typeof parsed.__generated_by === 'string' && parsed.__generated_by.startsWith('agentrc@')
      );
    } catch {
      return false;
    }
  }
  return false;
}

// Add a generated header to file content based on the file extension
export function addGeneratedHeader(content: string, filePath: string): string {
  const ext = extname(filePath).toLowerCase();

  switch (ext) {
    case '.md': {
      return `${MD_HEADER}\n${content}`;
    }
    case '.json': {
      return addJsonHeader(content);
    }
    case '.yml':
    case '.yaml': {
      return `${YAML_HEADER}\n${content}`;
    }
    default: {
      // For unknown extensions, no header added
      return content;
    }
  }
}

// Insert the __generated_by key as the first key in a JSON string
function addJsonHeader(content: string): string {
  try {
    const parsed = JSON.parse(content) as Record<string, unknown>;
    // Build a new object with __generated_by first, then the rest
    const result: Record<string, unknown> = {
      __generated_by: JSON_GENERATED_KEY,
      ...parsed,
    };
    return `${JSON.stringify(result, null, 2)}\n`;
  } catch {
    // If content isn't valid JSON, just return as-is
    return content;
  }
}

// Deep merge two objects. Arrays are replaced, not merged.
// Source values overwrite target values for matching keys.
function deepMerge(
  target: Record<string, unknown>,
  source: Record<string, unknown>,
): Record<string, unknown> {
  const result = { ...target };

  for (const key of Object.keys(source)) {
    const sourceVal = source[key];
    const targetVal = result[key];

    if (
      sourceVal !== null &&
      typeof sourceVal === 'object' &&
      !Array.isArray(sourceVal) &&
      targetVal !== null &&
      typeof targetVal === 'object' &&
      !Array.isArray(targetVal)
    ) {
      result[key] = deepMerge(
        targetVal as Record<string, unknown>,
        sourceVal as Record<string, unknown>,
      );
    } else {
      result[key] = sourceVal;
    }
  }

  return result;
}

async function fileExists(path: string): Promise<boolean> {
  try {
    await stat(path);
    return true;
  } catch {
    return false;
  }
}

async function readFileContent(path: string): Promise<string | null> {
  try {
    return await readFile(path, 'utf-8');
  } catch {
    return null;
  }
}

// Back up an existing file before overwriting it
async function backupFile(
  filePath: string,
  rootDir: string,
  dryRun: boolean,
): Promise<string | null> {
  const absPath = join(rootDir, filePath);
  const exists = await fileExists(absPath);
  if (!exists) return null;

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const backupPath = join(rootDir, BACKUP_DIR, `${filePath}.${timestamp}`);

  if (!dryRun) {
    await mkdir(dirname(backupPath), { recursive: true });
    await cp(absPath, backupPath);
  }

  return backupPath;
}

// Handle writing a JSON file with key-level merging
async function writeJsonFile(
  filePath: string,
  content: string,
  rootDir: string,
  dryRun: boolean,
): Promise<{ finalContent: string; backedUp: string | null; warning: string | null }> {
  const absPath = join(rootDir, filePath);
  const existingContent = await readFileContent(absPath);

  // No existing file: write the full content with header
  if (existingContent === null) {
    const finalContent = addJsonHeader(content);
    return { finalContent, backedUp: null, warning: null };
  }

  // Existing file with agentrc header: overwrite entirely
  if (hasGeneratedHeader(existingContent)) {
    const finalContent = addJsonHeader(content);
    return { finalContent, backedUp: null, warning: null };
  }

  // Existing file WITHOUT agentrc header: deep merge our keys into it, backup first
  const backedUp = await backupFile(filePath, rootDir, dryRun);

  try {
    const existingParsed = JSON.parse(existingContent) as Record<string, unknown>;
    const newParsed = JSON.parse(content) as Record<string, unknown>;
    const merged = deepMerge(existingParsed, newParsed);

    // Add our header key first
    const withHeader: Record<string, unknown> = {
      __generated_by: JSON_GENERATED_KEY,
      ...merged,
    };
    const finalContent = `${JSON.stringify(withHeader, null, 2)}\n`;
    return { finalContent, backedUp, warning: null };
  } catch {
    // If we can't parse the existing file, just overwrite with header
    const finalContent = addJsonHeader(content);
    return {
      finalContent,
      backedUp,
      warning: `Could not parse existing JSON at ${filePath}, overwriting`,
    };
  }
}

// Handle writing a non-JSON file (markdown, yaml, etc.)
async function writeStandardFile(
  filePath: string,
  content: string,
  rootDir: string,
  dryRun: boolean,
): Promise<{ finalContent: string; backedUp: string | null; warning: string | null }> {
  const absPath = join(rootDir, filePath);
  const existingContent = await readFileContent(absPath);
  let warning: string | null = null;

  // If file exists without our header, back it up
  let backedUp: string | null = null;
  if (existingContent !== null && !hasGeneratedHeader(existingContent)) {
    backedUp = await backupFile(filePath, rootDir, dryRun);
  }

  const finalContent = addGeneratedHeader(content, filePath);

  // Check if a previously generated file was manually edited
  if (existingContent !== null && hasGeneratedHeader(existingContent)) {
    const oldManifest = await readManifest(rootDir);
    if (oldManifest) {
      const entry = oldManifest.files.find((f) => f.path === filePath);
      if (entry && computeHash(existingContent) !== entry.hash) {
        warning = `${filePath} was manually edited since last generation`;
      }
    }
  }

  return { finalContent, backedUp, warning };
}

// Write adapter output files to disk, handling headers, merging, backups, and manifest
export async function writeOutputFiles(
  files: OutputFile[],
  options: WriteOptions,
): Promise<WriteResult> {
  const { rootDir, dryRun = false } = options;
  const written: string[] = [];
  const backed_up: string[] = [];
  const warnings: string[] = [];
  const manifestEntries: ManifestEntry[] = [];

  for (const file of files) {
    const ext = extname(file.path).toLowerCase();
    let result: { finalContent: string; backedUp: string | null; warning: string | null };

    if (ext === '.json') {
      result = await writeJsonFile(file.path, file.content, rootDir, dryRun);
    } else {
      result = await writeStandardFile(file.path, file.content, rootDir, dryRun);
    }

    if (result.backedUp) {
      backed_up.push(result.backedUp);
    }
    if (result.warning) {
      warnings.push(result.warning);
    }

    if (!dryRun) {
      const absPath = join(rootDir, file.path);
      await mkdir(dirname(absPath), { recursive: true });
      await writeFile(absPath, result.finalContent, 'utf-8');
    }

    written.push(file.path);
    manifestEntries.push({
      path: file.path,
      hash: computeHash(result.finalContent),
    });
  }

  // Detect stale files from previous manifest that are no longer generated
  const oldManifest = await readManifest(rootDir);
  if (oldManifest) {
    const currentPaths = new Set(files.map((f) => f.path));
    for (const entry of oldManifest.files) {
      if (!currentPaths.has(entry.path)) {
        warnings.push(`Stale generated file detected: ${entry.path} (no longer in output)`);
      }
    }
  }

  // Write the manifest
  if (!dryRun) {
    const manifest: Manifest = {
      version: VERSION,
      generatedAt: new Date().toISOString(),
      files: manifestEntries,
    };
    const manifestAbsPath = join(rootDir, MANIFEST_PATH);
    await mkdir(dirname(manifestAbsPath), { recursive: true });
    await writeFile(manifestAbsPath, `${JSON.stringify(manifest, null, 2)}\n`, 'utf-8');
  }

  return { written, backed_up, warnings };
}

// Read the existing manifest from disk
export async function readManifest(rootDir: string): Promise<Manifest | null> {
  const content = await readFileContent(join(rootDir, MANIFEST_PATH));
  if (content === null) return null;

  try {
    return JSON.parse(content) as Manifest;
  } catch {
    return null;
  }
}

// Remove all generated files tracked by the manifest
export async function cleanGeneratedFiles(rootDir: string): Promise<string[]> {
  const manifest = await readManifest(rootDir);
  if (!manifest) return [];

  const { unlink } = await import('node:fs/promises');
  const removed: string[] = [];

  for (const entry of manifest.files) {
    const absPath = join(rootDir, entry.path);
    try {
      await unlink(absPath);
      removed.push(entry.path);
    } catch {
      // File already gone, that's fine
    }
  }

  // Remove the manifest itself
  try {
    await unlink(join(rootDir, MANIFEST_PATH));
  } catch {
    // Already gone
  }

  return removed;
}
