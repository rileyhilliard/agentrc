import { describe, expect, test } from 'bun:test';
import { mkdir, mkdtemp, readFile, rm, writeFile } from 'node:fs/promises';
import { tmpdir } from 'node:os';
import { join } from 'node:path';
import {
  addGeneratedHeader,
  computeHash,
  hasGeneratedHeader,
  readManifest,
  writeOutputFiles,
} from '../../src/output/writer.ts';

async function createTempDir(): Promise<string> {
  return mkdtemp(join(tmpdir(), 'agentrc-writer-test-'));
}

describe('computeHash', () => {
  test('returns consistent hash for same content', () => {
    const hash1 = computeHash('hello world');
    const hash2 = computeHash('hello world');
    expect(hash1).toBe(hash2);
  });

  test('returns different hash for different content', () => {
    const hash1 = computeHash('hello');
    const hash2 = computeHash('world');
    expect(hash1).not.toBe(hash2);
  });

  test('returns 64-char hex string (sha256)', () => {
    const hash = computeHash('test');
    expect(hash).toMatch(/^[0-9a-f]{64}$/);
  });
});

describe('addGeneratedHeader', () => {
  test('adds markdown comment header to .md files', () => {
    const result = addGeneratedHeader('# Title\n\nContent', 'test.md');
    expect(result).toContain('<!-- Generated by agentrc');
    expect(result).toContain('# Title');
  });

  test('adds yaml comment header to .yaml files', () => {
    const result = addGeneratedHeader('key: value', 'test.yaml');
    expect(result).toContain('# Generated by agentrc');
    expect(result).toContain('key: value');
  });

  test('adds __generated_by key to .json files', () => {
    const result = addGeneratedHeader('{"hooks": {}}', 'test.json');
    const parsed = JSON.parse(result) as Record<string, unknown>;
    expect(parsed.__generated_by).toBeDefined();
    expect(typeof parsed.__generated_by).toBe('string');
    expect((parsed.__generated_by as string).startsWith('agentrc@')).toBe(true);
  });

  test('returns content unchanged for unknown extensions', () => {
    const content = 'some content';
    const result = addGeneratedHeader(content, 'test.txt');
    expect(result).toBe(content);
  });
});

describe('hasGeneratedHeader', () => {
  test('detects markdown generated header', () => {
    const content =
      '<!-- Generated by agentrc v0.1.0 — edit .agentrc/ instead, changes here will be overwritten -->\n# Content';
    expect(hasGeneratedHeader(content)).toBe(true);
  });

  test('detects yaml generated header', () => {
    const content =
      '# Generated by agentrc v0.1.0 — edit .agentrc/ instead, changes here will be overwritten\nkey: value';
    expect(hasGeneratedHeader(content)).toBe(true);
  });

  test('detects json generated header', () => {
    const content = JSON.stringify({ __generated_by: 'agentrc@0.1.0', hooks: {} });
    expect(hasGeneratedHeader(content)).toBe(true);
  });

  test('returns false for content without header', () => {
    expect(hasGeneratedHeader('# Just a title\n\nSome content')).toBe(false);
    expect(hasGeneratedHeader('{"key": "value"}')).toBe(false);
  });
});

describe('writeOutputFiles', () => {
  test('writes files to disk', async () => {
    const tempDir = await createTempDir();
    try {
      const files = [
        { path: 'CLAUDE.md', content: '# Rules\n\nBe strict.\n' },
        { path: '.claude/commands/test.md', content: 'Run tests.\n' },
      ];

      const result = await writeOutputFiles(files, { rootDir: tempDir });

      expect(result.written).toEqual(['CLAUDE.md', '.claude/commands/test.md']);

      // Verify files actually exist on disk
      const claudeMd = await readFile(join(tempDir, 'CLAUDE.md'), 'utf-8');
      expect(claudeMd).toContain('# Rules');
      expect(claudeMd).toContain('Generated by agentrc');

      const testCmd = await readFile(join(tempDir, '.claude/commands/test.md'), 'utf-8');
      expect(testCmd).toContain('Run tests');
    } finally {
      await rm(tempDir, { recursive: true, force: true });
    }
  });

  test('creates manifest after writing', async () => {
    const tempDir = await createTempDir();
    try {
      const files = [{ path: 'CLAUDE.md', content: '# Content\n' }];
      await writeOutputFiles(files, { rootDir: tempDir });

      const manifest = await readManifest(tempDir);
      expect(manifest).not.toBeNull();
      expect(manifest?.files).toHaveLength(1);
      expect(manifest?.files[0]?.path).toBe('CLAUDE.md');
      expect(manifest?.files[0]?.hash).toMatch(/^[0-9a-f]{64}$/);
      expect(manifest?.version).toBe('0.1.0');
    } finally {
      await rm(tempDir, { recursive: true, force: true });
    }
  });

  test('dry run does not write files', async () => {
    const tempDir = await createTempDir();
    try {
      const files = [{ path: 'CLAUDE.md', content: '# Content\n' }];
      const result = await writeOutputFiles(files, { rootDir: tempDir, dryRun: true });

      expect(result.written).toEqual(['CLAUDE.md']);

      // File should NOT exist
      await expect(readFile(join(tempDir, 'CLAUDE.md'), 'utf-8')).rejects.toThrow();
    } finally {
      await rm(tempDir, { recursive: true, force: true });
    }
  });

  test('backs up non-generated existing files', async () => {
    const tempDir = await createTempDir();
    try {
      // Create a pre-existing file without agentrc header
      await mkdir(join(tempDir), { recursive: true });
      await writeFile(join(tempDir, 'CLAUDE.md'), '# My custom rules\n');

      const files = [{ path: 'CLAUDE.md', content: '# Generated rules\n' }];
      const result = await writeOutputFiles(files, { rootDir: tempDir });

      expect(result.backed_up.length).toBe(1);
      expect(result.backed_up[0]).toContain('.agentrc/.backup');
    } finally {
      await rm(tempDir, { recursive: true, force: true });
    }
  });

  test('does not back up already-generated files', async () => {
    const tempDir = await createTempDir();
    try {
      // Write once (this creates a generated file)
      const files = [{ path: 'CLAUDE.md', content: '# Rules\n' }];
      await writeOutputFiles(files, { rootDir: tempDir });

      // Write again (should not back up since it has our header)
      const result = await writeOutputFiles(files, { rootDir: tempDir });
      expect(result.backed_up.length).toBe(0);
    } finally {
      await rm(tempDir, { recursive: true, force: true });
    }
  });

  test('deep-merges JSON files without agentrc header', async () => {
    const tempDir = await createTempDir();
    try {
      // Create existing .claude/settings.json with user content
      await mkdir(join(tempDir, '.claude'), { recursive: true });
      await writeFile(
        join(tempDir, '.claude/settings.json'),
        JSON.stringify({ userSetting: true, shared: { a: 1 } }, null, 2),
      );

      const files = [
        {
          path: '.claude/settings.json',
          content: JSON.stringify({ hooks: {}, shared: { b: 2 } }, null, 2),
        },
      ];
      const result = await writeOutputFiles(files, { rootDir: tempDir });

      const content = await readFile(join(tempDir, '.claude/settings.json'), 'utf-8');
      const parsed = JSON.parse(content) as Record<string, unknown>;

      // Should have the generated-by header
      expect(parsed.__generated_by).toBeDefined();
      // Should have user's original setting
      expect(parsed.userSetting).toBe(true);
      // Should have our hooks
      expect(parsed.hooks).toBeDefined();
      // Should deep-merge shared
      const shared = parsed.shared as Record<string, unknown>;
      expect(shared.a).toBe(1);
      expect(shared.b).toBe(2);

      // Should have backed up
      expect(result.backed_up.length).toBe(1);
    } finally {
      await rm(tempDir, { recursive: true, force: true });
    }
  });

  test('detects stale files from previous manifest', async () => {
    const tempDir = await createTempDir();
    try {
      // First generation: two files
      const files1 = [
        { path: 'CLAUDE.md', content: '# Rules\n' },
        { path: '.claude/commands/test.md', content: 'Test\n' },
      ];
      await writeOutputFiles(files1, { rootDir: tempDir });

      // Second generation: only one file
      const files2 = [{ path: 'CLAUDE.md', content: '# Updated rules\n' }];
      const result = await writeOutputFiles(files2, { rootDir: tempDir });

      const staleWarning = result.warnings.find((w) => w.includes('Stale'));
      expect(staleWarning).toBeDefined();
      expect(staleWarning).toContain('.claude/commands/test.md');
    } finally {
      await rm(tempDir, { recursive: true, force: true });
    }
  });
});
